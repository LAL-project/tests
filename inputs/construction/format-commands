
COMMANDS AVAILABLE
==================

** /* COMMENTS */
	Comments are delimited by an opening '/*' and a closing '*/'.

** output STRING
	Outputs to standard output string STRING. A valid string is one that is enclosed with ".

** create_graph TYPE GRAPH N
	Creates a graph of a certain TYPE and a given number of vertices N
	Types supported:
		- undirected
		- directed
		- rooted_directed_tree

** read_graph GRAPH_TYPE GRAPH FILE FILE_TYPE true/false
	Reads a directed/undirected (type) graph from file FILE into variable GRAPH.
	The type file is a string for the format of the graph stored in the file.
	Allowed strings:
		- edge_list

** output_graph GRAPH
	Outputs a graph to standard output

** add_edge GRAPH VERTEX1 VERTEX2 true/false
	Adds an edge to a graph. Normalises (or not) the graph
	
** add_edges GRAPH N VERTEX1 VERTEX2 ... VERTEX_{2n-1} VERTEX_{2n} true/false
	Adds N edges to a graph. Normalises (or not) the graph

** check_edge_iterator GRAPH
	Builds the list of edges for a graph and asserts that is the same
	as that returned by a brute force method.

** check_Q_iterator GRAPH
	Builds the list of pairs of independent edges for a graph and asserts
	that is the same as that returned by a brute force method method.

** normalise GRAPH
	Normalise a graph
	
** assign GRAPH1 GRAPH2
	Assign graph 2 to graph 1
	
** disjoint_union GRAPH_RESULT GRAPH1 GRAPH2
	Make the disjoint union of GRAPH1 and GRAPH2 and store the result
	in GRAPH_RESULT

+++++++++++++++++++++++++++++++++++++++++

** assert
	Makes sure that something is true
	
	-- equal_graphs GRAPH1 GRAPH2
		asserts that two graphs are equal (here "equal" is not the
		same as "isomorphic"!)
	
	-- not_equal_graphs GRAPH1 GRAPH2
		asserts that two graphs are equal (here "equal" is not the
		same as "isomorphic"!)
	
	-- neighbours_are GRAPH VERTEX0 N VERTEX1 ... VERTEXN
		asserts that the neighbours of VERTEX0 in graph GRAPH are VERTEX1 ... VERTEXN
	
	-- normalised GRAPH
		asserts that a graph IS normalised
	
	-- not_normalised GRAPH
		asserts that a graph IS NOT normalised
	
	-- exists_edge GRAPH VERTEX1 VERTEX2
		asserts that a given edge exists
	
	-- not_exists_edge GRAPH VERTEX1 VERTEX2
		asserts that a given edge does NOT exist
	
	-- num_nodes GRAPH N
		asserts that the number of nodes is N
		
	-- num_edges GRAPH N
		asserts that the number of edges is N
	
	-- edges_are GRAPH N VERTEX1 VERTEX2 ... VERTEX_{2n-1} VERTEX_{2n}
		asserts that the edges in the graph are those specified in the list.
		In case of undirected graphs, the edges must be given in lexicographic
		order, i.e., the edges (s,t) given must be such that s<t.
	
	-- elements_Q_are GRAPH N VERTEX1 VERTEX2 ... VERTEX_{4n-1} VERTEX_{4n}
		asserts that the pairs of independent edges in the graph are
		those specified in the list.
		In case of undirected graphs, the edges must be given in lexicographic
		order, i.e., the edges (s,t) given must be such that s < t.
		For both directed and undirected graphs, the pairs ((s,t),(u,v))
		must be given also in lexicographic order, i.e., s<u.
	
	-- is_undirected GRAPH
		asserts that the graph is undirected
	
	-- not_undirected GRAPH
		asserts that the graph is undirected
	
	-- is_directed GRAPH
		asserts that the graph is directed
	
	-- not_directed GRAPH
		asserts that the graph is directed
	
	-- degree GRAPH NODE d
		asserts that the degree (out-degree + in-degree for directed
		graphs) equals d
	
	DIRECTED GRAPHS (including trees)
	===============
	
	-- in_neighbours_are GRAPH VERTEX0 N VERTEX1 ... VERTEXN
		asserts that the in-neighbours of VERTEX0 in graph GRAPH are VERTEX1 ... VERTEXN
	
	-- full_degree GRAPH NODE d
		asserts that the in-degree plus out-degree equals d.
	
	-- in_degree GRAPH NODE d
		asserts that the in-degree equals d.
	
	-- out_degree GRAPH NODE d
		asserts that the out-degree equals d.
	
	TREES
	=====
	
	-- is_tree TREE
		Asserts that tree TREE has one edge less than the number of vertices.
		Under a constrained addition of edges, this assertion not failing ensures
		that TREE is an actual tree.
		
	-- is_not_tree TREE
		Asserts that tree TREE has one edge less than the number of vertices.
		Under a constrained addition of edges, this assertion failing ensures
		that TREE is not an actual tree.
	
	-- can_add_edge TREE VERTEX_1 VERTEX_2
		asserts that an edge can be added to the graph
		
	-- cant_add_edge TREE VERTEX_1 VERTEX_2
		asserts that an edge can NOT be added to the graph
	
	-- can_add_edges TREE N VERTEX_1 VERTEX_2 .. VERTEX_{2N-1} VERTEX_{2N}
		asserts that the edges in the list can be added to the graph
		
	-- cant_add_edges TREE N VERTEX_1 VERTEX_2 .. VERTEX_{2N-1} VERTEX_{2N}
		asserts that the edges in the list cant be added to the graph
	
	-- is_rooted TREE
		asserts that the tree is rooted
	
	-- is_not_rooted TREE
		asserts that the tree is NOT rooted
	
	ROOTED TREES
	============
	
	-- no_need_recalc_subtree_size TREE
		asserts that the number of subtrees calculated is valid.
	
	-- need_recalc_subtree_size TREE
		asserts that the number of subtrees calculated is not valid.
	
	-- has_root TREE
		asserts that the rooted tree has a root.
	
	-- not_has_root TREE
		asserts that the rooted tree does not have a root.
		
	-- num_nodes_subtree TREE NODE SIZE
		asserts that the subtree of GRAPH rooted at node NODE has size SIZE
	
	ROOTED DIRECTED TREES
	=====================
	
	-- drtree_type_valid TREE
		asserts that the type of rooted directed tree is valid.
	
	-- drtree_type_not_valid TREE
		asserts that the type of rooted directed tree is not valid.
	
	-- is_drtree_type TREE TYPE
		asserts that directed rooted tree GRAPH is of type TYPE.
		Allowed strings for TYPE:
			"arborescence", "anti_arborescence", "none"
	
	-- is_not_drtree_type TREE TYPE
		asserts that directed rooted tree GRAPH is NOT of type TYPE.
		Allowed strings for TYPE:
			"arborescence", "anti_arborescence", "none"

+++++++++++++++++++++++++++++++++++++++++

DIRECTED GRAPHS (excluding trees)
===============

** dgraph_to_ugraph TREE_RESULT TREE
	Converts the directed graph TREE into an undirected graph TREE_RESULT

UNDIRECTED TREES
================

** utree_to_drtree TREE_RESULT TREE ROOT_NODE
	Converts the undirected tree TREE into a rooted directed tree TREE_RESULT
	taking node ROOT_NODE as its root.

ROOTED TREES
============

** set_root TREE NODE
	Sets the root NODE to TREE.
	If the graph is a directed rooted tree then it calls the drtree class
	method 'find_drtree_type()'.

** retrieve_subtree TREE_RESULT TREE NODE
	Retrieves the subtree of a rooted tree TREE into tree TREE_RESULT.
	The tree must have a root.

UNDIRECTED ROOTED TREES
=======================

** calculate_size_subtrees TREE
	Calculates the size of each subtree of the rooted tree.
	The tree must have a root.

DIRECTED ROOTED TREES
=====================

** calculate_size_subtrees TREE true/false
	Calculates the size of each subtree of the rooted tree.
	The tree must have a root. The Boolean value indicates that whether
	reversed edges should be used or not.

** find_drtree_type GRAPH
	Calculates the type of the directed rooted tree.
	The tree must have a root.
