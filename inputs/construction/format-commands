
COMMANDS AVAILABLE
==================

** create_graph TYPE GRAPH N
	Creates a graph of a certain TYPE and a given number of vertices N
	Types supported:
		- undirected
		- directed
		- rooted_directed_tree

** read_graph GRAPH_TYPE GRAPH FILE FILE_TYPE true/false
	Reads a directed/undirected (type) graph from file FILE into variable GRAPH.
	The type file is a string for the format of the graph stored in the file.
	Allowed strings:
		- edge_list

** output_graph GRAPH
	Outputs a graph to standard output

** add_edge GRAPH VERTEX1 VERTEX2 true/false
	Adds an edge to a graph. Normalises (or not) the graph
	
** add_edges GRAPH N VERTEX1 VERTEX2 ... VERTEX_{2n-1} VERTEX_{2n} true/false
	Adds N edges to a graph. Normalises (or not) the graph
	
** assert
	Makes sure that something is true
	
	-- normalised GRAPH
		asserts that a graph IS normalised
	
	-- not_normalised GRAPH
		asserts that a graph IS NOT normalised
		
	-- equal_graphs GRAPH1 GRAPH2
		asserts that two graphs are equal (here "equal" is not the
		same as "isomorphic"!)
	
	-- not_equal_graphs GRAPH1 GRAPH2
		asserts that two graphs are equal (here "equal" is not the
		same as "isomorphic"!)
	
	-- neighbours_are GRAPH VERTEX0 N VERTEX1 ... VERTEXN
		asserts that the neighbours of VERTEX0 in graph GRAPH are VERTEX1 ... VERTEXN
	
	-- exists_edge GRAPH VERTEX1 VERTEX2
		asserts that a given edge exists
	
	-- not_exists_edge GRAPH VERTEX1 VERTEX2
		asserts that a given edge does NOT exist
	
	-- num_nodes GRAPH N
		asserts that the number of nodes is N
		
	-- num_edges GRAPH N
		asserts that the number of edges is N
	
	-- edges_are GRAPH N VERTEX1 VERTEX2 ... VERTEX_{2n-1} VERTEX_{2n}
		asserts that the edges in the graph are those specified in the list.
		In case of undirected graphs, the edges must be given in lexicographic
		order, i.e., the edges (s,t) given must be such that s<t.
	
	-- elements_Q_are GRAPH N VERTEX1 VERTEX2 ... VERTEX_{4n-1} VERTEX_{4n}
		asserts that the pairs of independent edges in the graph are
		those specified in the list.
		In case of undirected graphs, the edges must be given in lexicographic
		order, i.e., the edges (s,t) given must be such that s < t.
		For both directed and undirected graphs, the pairs ((s,t),(u,v))
		must be given also in lexicographic order, i.e., s<u.
	
	-- is_directed GRAPH
		asserts that the graph is directed
	
	-- not_directed GRAPH
		asserts that the graph is directed
		
	-- is_undirected GRAPH
		asserts that the graph is undirected
	
	-- not_undirected GRAPH
		asserts that the graph is undirected
	
	-- degree GRAPH NODE d
		asserts that the degree (out-degree + in-degree for directed
		graphs) equals d
	
	DIRECTED GRAPHS
	===============
	
	-- in_neighbours_are GRAPH VERTEX0 N VERTEX1 ... VERTEXN
		asserts that the in-neighbours of VERTEX0 in graph GRAPH are VERTEX1 ... VERTEXN
	
	-- full_degree GRAPH NODE d
		asserts that the in-degree plus out-degree equals d.
	
	-- in_degree GRAPH NODE d
		asserts that the in-degree equals d.
	
	-- out_degree GRAPH NODE d
		asserts that the out-degree equals d.
	
	TREES
	=====
	
	-- can_add_edge GRAPH VERTEX_1 VERTEX_2
		asserts that an edge can be added to the graph
		
	-- cant_add_edge GRAPH VERTEX_1 VERTEX_2
		asserts that an edge can NOT be added to the graph
	
	-- can_add_edges GRAPH N VERTEX_1 VERTEX_2 .. VERTEX_{2N-1} VERTEX_{2N}
		asserts that the edges in the list can be added to the graph
		
	-- cant_add_edges GRAPH N VERTEX_1 VERTEX_2 .. VERTEX_{2N-1} VERTEX_{2N}
		asserts that the edges in the list cant be added to the graph
	
	-- is_rooted GRAPH
		asserts that the tree is rooted
	
	-- is_not_rooted GRAPH
		asserts that the tree is NOT rooted
	
	ROOTED TREES
	============
	
	-- has_root GRAPH
		asserts that the rooted tree has a root
	
	-- not_has_root GRAPH
		asserts that the rooted tree does not have a root
	
	ROOTED DIRECTED TREES
	=====================
	
	-- is_drtree_type GRAPH TYPE
		asserts that directed rooted tree GRAPH is of type TYPE.
		Allowed strings for TYPE:
			"arborescence", "anti_arborescence", "none"
	
	-- is_not_drtree_type GRAPH TYPE
		asserts that directed rooted tree GRAPH is NOT of type TYPE.
		Allowed strings for TYPE:
			"arborescence", "anti_arborescence", "none"
	
** check_edge_iterator GRAPH
	Builds the list of edges for a graph and asserts that is the same
	as that returned by a brute force method.

** check_Q_iterator GRAPH
	Builds the list of pairs of independent edges for a graph and asserts
	that is the same as that returned by a brute force method method.

** normalise GRAPH
	Normalise a graph
	
** assign GRAPH1 GRAPH2
	Assign graph 2 to graph 1
	
** disjoint_union GRAPH_RESULT GRAPH1 GRAPH2
	Make the disjoint union of GRAPH1 and GRAPH2 and store the result
	in GRAPH_RESULT

UNDIRECTED GRAPHS
=================

** to_drtree GRAPH_RESULT GRAPH ROOT_NODE
	Converts undirected graph GRAPH into a rooted directed tree GRAPH_RESULT
	taking node ROOT_NODE as its root.

DIRECTED GRAPHS
===============

** to_undirected GRAPH_RESULT GRAPH
	Converts the directed graph GRAPH into an undirected graph GRAPH_RESULT

ROOTED TREES
============

** set_root GRAPH NODE
	Sets the root NODE to GRAPH.
	If the graph is a directed rooted tree then it calls the drtree class
	method 'find_drtree_type()'.

** size_subtree GRAPH NODE
	Outputs the size of the subtree rooted at NODE of GRAPH.
